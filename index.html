<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moodle XML Quiz Viewer</title>
    
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.11/dist/purify.min.js"></script>

    <style>
        /* Styles remain the same */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            line-height: 1.6; color: #333; max-width: 800px;
            margin: 20px auto; padding: 0 15px; background-color: #f9f9f9;
        }
        h1, h2, h3 { color: #005A9C; }
        h3.category-title {
            color: #555; border-bottom: 2px solid #0078D4; padding-bottom: 5px; margin-top: 0;
        }
        #setup, #quiz-container, #score-container {
            background-color: #fff; padding: 25px; border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 20px;
        }
        label { font-weight: bold; display: block; margin-bottom: 5px; }
        input[type="url"], input[type="text"], input[type="number"], textarea, select {
            width: 100%; padding: 8px; margin-bottom: 10px;
            border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;
        }
        textarea { height: 150px; resize: vertical; }
        button {
            background-color: #0078D4; color: white; padding: 10px 15px;
            border: none; border-radius: 4px; cursor: pointer; font-size: 16px; margin-top: 10px;
        }
        button:hover { background-color: #005A9C; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .question-text { font-size: 1.2em; margin-bottom: 20px; }
        .answer-choice { margin-bottom: 10px; }
        .answer-choice label { font-weight: normal; display: inline; }
        .feedback {
            padding: 15px; margin-top: 15px; border-radius: 4px; border-left: 5px solid;
        }
        .feedback.correct { background-color: #e9f7ef; border-color: #28a745; }
        .feedback.partial { background-color: #fff3cd; border-color: #ffc107; }
        .feedback.incorrect { background-color: #f8d7da; border-color: #dc3545; }
        .feedback-general { background-color: #eef; border-color: #66f; }
        .matching-container { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items: center; }
        #score-display { font-size: 1.2em; font-weight: bold; }
        .cloze-warning, .unsupported-warning {
            font-size: 0.9em; color: #856404; background-color: #fff3cd;
            border: 1px solid #ffeeba; padding: 10px; border-radius: 4px; margin-bottom: 15px;
        }
        .cloze-options-container.horizontal { display: inline-flex; flex-wrap: wrap; gap: 15px; vertical-align: middle; }
        .cloze-options-container.vertical { display: block; margin: 5px 0; }
        .cloze-option { display: inline-block; margin-right: 10px; }
        .cloze-option label { font-weight: normal; }
        .cloze-text-input { width: 150px; display: inline-block; }
        #progress-container { width: 100%; margin-top: 15px; }
        #progress-bar-bg { background-color: #e0e0e0; border-radius: 4px; padding: 2px; box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); }
        #progress-bar { width: 0%; height: 18px; background-color: #0078D4; border-radius: 2px; transition: width 0.3s ease-in-out; }
        #progress-text { text-align: right; margin-bottom: 5px; font-size: 0.9em; color: #555; }
    </style>
</head>
<body>
    <h1>Moodle XML Quiz Viewer üìù</h1>

    <div id="setup">
        <h2>Load Your Quiz</h2>
        <p>Provide a link to a Moodle XML file or paste its contents below.</p>
        <label for="xml-url">1. Load from URL</label>
        <input type="url" id="xml-url" placeholder="https://example.com/quiz.xml">
        <label for="xml-input">2. Or Paste XML Content</label>
        <textarea id="xml-input" placeholder="<quiz>...</quiz>"></textarea>
        <button id="start-btn">Start Quiz</button>
    </div>

    <div id="quiz-container" style="display:none;">
        <div id="category-display"></div>
        <div id="question-area"></div>
        <div id="feedback-area"></div>
        <button id="next-btn" style="display:none;">Next Question</button>
    </div>

    <div id="score-container" style="display:none;">
        <h2>Progress</h2>
        <div id="score-display"></div>
        <div id="progress-container">
            <div id="progress-text"></div>
            <div id="progress-bar-bg">
                <div id="progress-bar"></div>
            </div>
        </div>
    </div>
    
<script>
    // --- GLOBALS ---
    const startBtn = document.getElementById('start-btn'), urlInput = document.getElementById('xml-url'),
        xmlInput = document.getElementById('xml-input'), setupContainer = document.getElementById('setup'),
        quizContainer = document.getElementById('quiz-container'), scoreContainer = document.getElementById('score-container'),
        questionArea = document.getElementById('question-area'), feedbackArea = document.getElementById('feedback-area'),
        nextBtn = document.getElementById('next-btn'), scoreDisplay = document.getElementById('score-display'),
        categoryDisplay = document.getElementById('category-display');
    let quizData = null, currentQuestionIndex = 0, score = 0, scorableQuestions = 0, scorableQuestionsAttempted = 0;

    // --- INITIALIZATION ---
    window.addEventListener('load', () => {
        const params = new URLSearchParams(window.location.search);
        const xmlUrl = params.get('url');
        if (xmlUrl) { urlInput.value = xmlUrl; loadQuizFromUrl(xmlUrl); }
    });

    startBtn.addEventListener('click', async () => {
        const url = urlInput.value.trim(), xml = xmlInput.value.trim();
        if (url) await loadQuizFromUrl(url);
        else if (xml) parseAndStartQuiz(xml);
        else alert('Please provide a URL or paste XML content.');
    });

    nextBtn.addEventListener('click', () => {
        currentQuestionIndex++;
        (currentQuestionIndex < quizData.length) ? renderQuestion(currentQuestionIndex) : displayFinalScore();
    });

    // --- QUIZ LOGIC ---
    async function loadQuizFromUrl(url) {
        try {
            const proxyUrl = `https://cors-anywhere.herokuapp.com/${url}`;
            const response = await fetch(proxyUrl);
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
            parseAndStartQuiz(await response.text());
        } catch (error) {
            alert(`Failed to load quiz from URL. Error: ${error.message}. Please try pasting the content directly.`);
        }
    }
    
    function parseAndStartQuiz(xmlText) {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "application/xml");
            if (xmlDoc.querySelector("parsererror")) throw new Error("Failed to parse XML.");
            const questions = Array.from(xmlDoc.getElementsByTagName('question'));
            if (questions.length === 0) throw new Error("No <question> tags found.");
            quizData = questions;
            const nonScorableTypes = ['description', 'category'];
            scorableQuestions = quizData.filter(q => !nonScorableTypes.includes(q.getAttribute('type'))).length;
            startQuiz();
        } catch(e) { alert(`Error: ${e.message}`); }
    }

    function startQuiz() {
        setupContainer.style.display = 'none'; quizContainer.style.display = 'block'; scoreContainer.style.display = 'block';
        currentQuestionIndex = 0; score = 0; scorableQuestionsAttempted = 0; categoryDisplay.innerHTML = '';
        updateScoreDisplay();
        renderQuestion(currentQuestionIndex);
    }
    
    function renderQuestion(index) {
        updateProgressDisplay();
        const qNode = quizData[index], qType = qNode.getAttribute('type');
        feedbackArea.innerHTML = ''; nextBtn.style.display = 'none'; questionArea.innerHTML = '';
        const qTextNode = qNode.querySelector('questiontext > text');
        
        const questionContent = getContentFromNode(qTextNode);
        
        const sanitizedQuestionText = DOMPurify.sanitize(questionContent);
        questionArea.insertAdjacentHTML('beforeend', `<div class="question-text">${sanitizedQuestionText}</div>`);
        
        const supportedRenderers = {
            'multichoice': renderMultichoice, 'truefalse': renderMultichoice, // truefalse is a type of multichoice
            'shortanswer': renderShortAnswer, 'numerical': renderNumerical, 'matching': renderMatching, 
            'essay': renderEssay, 'cloze': renderCloze, 'description': renderDescription, 'category': renderCategory
        };

        const renderer = supportedRenderers[qType] || renderUnsupported;
        renderer(qNode);
    }

    // --- RENDERER FUNCTIONS ---
    function renderMultichoice(qNode) {
        const questionType = qNode.getAttribute('type');
        const answers = Array.from(qNode.getElementsByTagName('answer'));
        let displayAnswers = [...answers];
        if (qNode.querySelector('shuffleanswers')?.textContent === '1') {
            displayAnswers.sort(() => Math.random() - 0.5);
        }
        
        // FIX #2: Ensure true/false questions are always single-choice (radio buttons)
        const isSingle = questionType === 'truefalse' || qNode.querySelector('single')?.textContent === 'true';

        let html = '<form class="answers">';
        displayAnswers.forEach((ans) => {
            const frac = parseFloat(ans.getAttribute('fraction'));
            const text = DOMPurify.sanitize(getContentFromNode(ans.querySelector('text')));
            const id = 'ans' + Math.random().toString(36).substring(2, 9);
            html += `<div class="answer-choice"><input type="${isSingle ? 'radio' : 'checkbox'}" name="answer" id="${id}" value="${frac}"><label for="${id}">${text}</label></div>`;
        });

        questionArea.insertAdjacentHTML('beforeend', html + '</form>');
        addSubmitButton(() => {
            let totalFraction = 0;
            document.querySelectorAll(`input[name="answer"]:checked`).forEach(i => totalFraction += parseFloat(i.value));
            totalFraction = Math.max(0, totalFraction);
            
            const isCorrect = totalFraction >= 100;
            if (isCorrect) {
                score++;
            }
            
            // Show specific feedback for the selected answer if available
            const selectedAnswerNode = document.querySelector(`input[name="answer"]:checked`);
            if (selectedAnswerNode) {
                const selectedIndex = Array.from(document.querySelectorAll(`input[name="answer"]`)).findIndex(input => input.id === selectedAnswerNode.id);
                const answerNode = displayAnswers[selectedIndex];
                const feedbackNode = answerNode.querySelector('feedback text');
                const feedbackContent = getContentFromNode(feedbackNode);
                if (feedbackContent.trim()) {
                    showFeedback(feedbackContent, isCorrect);
                } else {
                     showFeedback(isCorrect ? 'Correct!' : 'Incorrect.', isCorrect);
                }
            } else {
                 showFeedback(isCorrect ? 'Correct!' : 'Incorrect.', isCorrect);
            }

            showGeneralFeedback(qNode);
            updateScoreDisplay();
        });
    }

    function renderShortAnswer(qNode) {
        questionArea.insertAdjacentHTML('beforeend', `<label for="sa-input">Your Answer:</label><input type="text" id="sa-input" />`);
        addSubmitButton(() => {
            const userInput = document.getElementById('sa-input').value.trim();
            const useCase = qNode.querySelector('usecase')?.textContent === '1';
            const answers = Array.from(qNode.getElementsByTagName('answer'));
            let bestMatch = { fraction: -1, feedback: 'Incorrect.' };

            for (const ans of answers) {
                const ansText = ans.querySelector('text').textContent;
                const ansFrac = parseFloat(ans.getAttribute('fraction'));
                let isMatch = false;
                
                if (ansText.includes('*')) {
                    const pattern = '^' + ansText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/\\\*/g, '.*') + '$';
                    const regex = new RegExp(pattern, useCase ? '' : 'i');
                    isMatch = regex.test(userInput);
                } else {
                    isMatch = useCase ? (userInput === ansText) : (userInput.toLowerCase() === ansText.toLowerCase());
                }

                if (isMatch && ansFrac > bestMatch.fraction) {
                    bestMatch = { fraction: ansFrac, feedback: getContentFromNode(ans.querySelector('feedback > text')) };
                }
            }
            const isCorrect = bestMatch.fraction >= 100;
            if (isCorrect) score++;

            const feedbackType = bestMatch.fraction > 0 ? (isCorrect ? true : 'partial') : false;
            let feedbackToShow = bestMatch.feedback && bestMatch.feedback.trim();

            if (!feedbackToShow) {
                // Provide default feedback if the matched answer has no specific feedback text
                if (bestMatch.fraction > 0) {
                    feedbackToShow = isCorrect ? 'Correct!' : 'Partially Correct.';
                } else {
                    feedbackToShow = 'Incorrect.';
                }
            }

            showFeedback(feedbackToShow, feedbackType);
            showGeneralFeedback(qNode);
            updateScoreDisplay();
        });
    }

    function renderNumerical(qNode) {
        questionArea.insertAdjacentHTML('beforeend', `<label for="num-input">Your Answer:</label><input type="number" id="num-input" step="any" />`);
        addSubmitButton(() => {
            const userInputText = document.getElementById('num-input').value.trim();
            if (userInputText === '') {
                showFeedback('Please enter a number.', false);
                showGeneralFeedback(qNode);
                return;
            }
            const userInput = parseFloat(userInputText);

            const answers = Array.from(qNode.getElementsByTagName('answer'));
            let bestMatch = { fraction: -1, feedback: 'Incorrect.' };

            for (const ans of answers) {
                const correctValue = parseFloat(ans.querySelector('text').textContent);
                const ansFrac = parseFloat(ans.getAttribute('fraction'));
                const tolerance = parseFloat(ans.querySelector('tolerance')?.textContent || '0');

                if (!isNaN(correctValue) && Math.abs(userInput - correctValue) <= tolerance) {
                    if (ansFrac > bestMatch.fraction) {
                        bestMatch = { fraction: ansFrac, feedback: getContentFromNode(ans.querySelector('feedback > text')) };
                    }
                }
            }

            const isCorrect = bestMatch.fraction >= 100;
            if (isCorrect) score++;

            const feedbackType = bestMatch.fraction > 0 ? (isCorrect ? true : 'partial') : false;
            let feedbackToShow = bestMatch.feedback && bestMatch.feedback.trim();

            if (!feedbackToShow) {
                if (bestMatch.fraction >= 100) {
                    feedbackToShow = 'Correct!';
                } else if (bestMatch.fraction > 0) {
                    feedbackToShow = 'Partially Correct.';
                } else {
                    feedbackToShow = 'Incorrect.';
                }
            }

            showFeedback(feedbackToShow, feedbackType);
            showGeneralFeedback(qNode);
            updateScoreDisplay();
        });
    }
    
    function renderMatching(qNode) {
        const subQuestions = Array.from(qNode.querySelectorAll('subquestion'));
        if (subQuestions.length === 0) {
            return renderUnsupported(qNode); // or handle as an error
        }

        const stems = subQuestions.map(sq => sq.querySelector('text').textContent.trim());
        const correctAnswers = subQuestions.map(sq => sq.querySelector('answer text').textContent.trim());

        let dropdownOptions = [...correctAnswers];
        if (qNode.querySelector('shuffleanswers')?.textContent !== '0') {
            dropdownOptions.sort(() => Math.random() - 0.5);
        }

        let html = '<div class="matching-container"><div class="stems" style="padding-right: 15px;">';
        stems.forEach((stem, index) => {
            html += `<div class="stem" data-index="${index}" style="margin-bottom: 15px;">${DOMPurify.sanitize(stem)}</div>`;
        });
        html += '</div><div class="responses">';

        stems.forEach((_, index) => {
            html += `<div class="response-container" style="margin-bottom: 15px;"><select class="matching-select" data-index="${index}">`;
            html += `<option value="">Select...</option>`;
            dropdownOptions.forEach(option => {
                html += `<option value="${escapeHTML(option)}">${DOMPurify.sanitize(option)}</option>`;
            });
            html += `</select></div>`;
        });
        html += '</div></div>';

        questionArea.insertAdjacentHTML('beforeend', html);

        addSubmitButton(() => {
            const selects = document.querySelectorAll('.matching-select');
            let correctMatches = 0;
            selects.forEach((select, index) => {
                if (select.value === correctAnswers[index]) {
                    correctMatches++;
                }
            });

            const totalQuestions = stems.length;
            const fraction = totalQuestions > 0 ? correctMatches / totalQuestions : 0;
            const isCorrect = correctMatches === totalQuestions;
            if (isCorrect) score++;

            let feedbackText = `You matched ${correctMatches} out of ${totalQuestions} correctly.`;
            let feedbackType = fraction === 1 ? true : (fraction > 0 ? 'partial' : false);

            showFeedback(feedbackText, feedbackType);
            showGeneralFeedback(qNode);
            updateScoreDisplay();
            selects.forEach(s => s.disabled = true);
        });
    }

    function renderEssay(qNode) {
        questionArea.insertAdjacentHTML('beforeend', `
            <p>This is an essay question. Your response will not be graded automatically.</p>
            <textarea id="essay-input" rows="10" placeholder="Type your essay here..."></textarea>
        `);
        const btn = document.createElement('button');
        btn.textContent = 'Continue';
        btn.onclick = () => {
            btn.disabled = true;
            nextBtn.style.display = 'block';
            document.getElementById('essay-input').disabled = true;
            showGeneralFeedback(qNode);
        };
        questionArea.appendChild(btn);
    }

    function renderCloze(qNode) {
        let questionText = getContentFromNode(qNode.querySelector('questiontext > text'));
        // Basic grading state
        let clozeSubQuestions = [];

        const renderedParts = questionText.split(/(\{[^}]+\})/g).filter(Boolean).map(part => {
            if (!part.startsWith('{') || !part.endsWith('}')) {
                return DOMPurify.sanitize(part);
            }

            const clozeIndex = clozeSubQuestions.length;
            const content = part.slice(1, -1);
            const [rawPoints, type, ...options] = content.split(':');
            const optionsString = options.join(':');
            const answers = optionsString.split('~').map(opt => {
                const match = opt.match(/^%(-?\d+)%(.*?)#?(.*)$/); // text and feedback
                if (match) return { fraction: parseInt(match[1], 10), text: match[2], feedback: match[3] };
                const simpleMatch = opt.match(/^%(-?\d+)%(.*)$/);
                if (simpleMatch) return { fraction: parseInt(simpleMatch[1], 10), text: simpleMatch[2], feedback: '' };
                return null;
            }).filter(Boolean);

            const typeUpper = type.toUpperCase();
            let subQuestion = { type: typeUpper, answers, correct: false, id: `cloze_${clozeIndex}` };

            if (typeUpper.startsWith('SA') || typeUpper.startsWith('MW')) {
                subQuestion.correctAnswer = answers.find(a => a.fraction === 100)?.text;
                clozeSubQuestions.push(subQuestion);
                return `<input type="text" class="cloze-text-input" id="${subQuestion.id}" />`;
            } else if (typeUpper.startsWith('MC')) {
                clozeSubQuestions.push(subQuestion);
                const isVertical = typeUpper.endsWith('V');
                const useRadios = typeUpper.startsWith('MC'); // Not MCA (checkbox)
                let html = `<span class="cloze-options-container ${isVertical ? 'vertical' : 'horizontal'}">`;
                answers.forEach((answer, idx) => {
                    const id = `${subQuestion.id}_${idx}`;
                    html += `<span class="cloze-option"><input type="${useRadios ? 'radio' : 'checkbox'}" name="${subQuestion.id}" id="${id}" value="${answer.fraction}"><label for="${id}">${DOMPurify.sanitize(answer.text)}</label></span>`;
                });
                return html + `</span>`;
            } else if (typeUpper.startsWith('NM')) {
                 // Simple numerical matching for now
                subQuestion.correctAnswer = answers.find(a => a.fraction === 100)?.text;
                clozeSubQuestions.push(subQuestion);
                return `<input type="number" class="cloze-text-input" id="${subQuestion.id}" />`;
            } else {
                return ` <span class="cloze-warning">[Unsupported cloze type: ${type}]</span> `;
            }
        });

        // The innerHTML of the question text contains the cloze placeholders.
        // We need to replace the placeholders with the rendered parts.
        // The question text is already in the DOM, so we can't just set innerHTML on questionArea.
        const questionTextElement = questionArea.querySelector('.question-text');
        // The content of the question text is already sanitized, but the rendered parts are not.
        // The rendered parts are sanitized inside the map function.
        questionTextElement.innerHTML = renderedParts.join('');

        addSubmitButton(() => {
            let clozeScore = 0;
            let maxClozeScore = clozeSubQuestions.length; // Simplified: 1 point per sub-question
            clozeSubQuestions.forEach(sq => {
                if (sq.type.startsWith('SA') || sq.type.startsWith('MW') || sq.type.startsWith('NM')) {
                    const input = document.getElementById(sq.id);
                    if (input && input.value.trim().toLowerCase() === sq.correctAnswer.toLowerCase()) {
                        clozeScore++;
                    }
                } else if (sq.type.startsWith('MC')) {
                    const inputs = document.querySelectorAll(`input[name="${sq.id}"]:checked`);
                    let totalFraction = 0;
                    inputs.forEach(i => totalFraction += parseFloat(i.value));
                    if (totalFraction >= 100) {
                        clozeScore++;
                    }
                }
            });

            // For simplicity, full credit if all parts are correct.
            if (clozeScore === maxClozeScore) {
                score++;
            }
            showFeedback(`You got ${clozeScore} out of ${maxClozeScore} parts correct.`, clozeScore === maxClozeScore);
            showGeneralFeedback(qNode);
            updateScoreDisplay();
        });
    }

    function renderDescription(qNode) {
        nextBtn.style.display = 'block';
    }

    function renderCategory(qNode) {
        const categoryText = qNode.querySelector('category > text').textContent;
        categoryDisplay.innerHTML = `<h3 class="category-title">${DOMPurify.sanitize(categoryText)}</h3>`;
        currentQuestionIndex++;
        (currentQuestionIndex < quizData.length) ? renderQuestion(currentQuestionIndex) : displayFinalScore();
    }

    function renderUnsupported(qNode) {
        const qType = qNode.getAttribute('type');
        questionArea.insertAdjacentHTML('beforeend', `
            <div class="unsupported-warning">
                <strong>Question type not supported:</strong> The question type "${escapeHTML(qType || 'unknown')}" will be skipped.
            </div>
        `);
        showGeneralFeedback(qNode);
        nextBtn.style.display = 'block';
    }

    // --- HELPER FUNCTIONS ---
    function getContentFromNode(node) {
        if (!node) return '';
        // Using innerHTML is the most reliable way to get the content of a node,
        // including handling CDATA sections correctly and preserving inner HTML tags.
        return node.innerHTML || '';
    }

    function addSubmitButton(onSubmit) {
        const btn = document.createElement('button'); btn.textContent = 'Submit Answer';
        btn.onclick = () => {
            scorableQuestionsAttempted++;
            onSubmit(); btn.disabled = true; nextBtn.style.display = 'block';
            document.querySelectorAll('form.answers input, .matching-select, #sa-input, #num-input, .cloze-text-input, .cloze-option input').forEach(el => el.disabled = true);
        };
        questionArea.appendChild(btn);
    }

    function showFeedback(text, type) {
        const className = type === true ? 'correct' : (type === false ? 'incorrect' : 'partial');
        feedbackArea.innerHTML += `<div class="feedback ${className}">${DOMPurify.sanitize(text)}</div>`;
    }

    function showGeneralFeedback(qNode) {
        const node = qNode.querySelector('generalfeedback > text');
        const feedbackContent = getContentFromNode(node);
        if (feedbackContent.trim()) {
            const sanitizedFeedback = DOMPurify.sanitize(feedbackContent);
            feedbackArea.innerHTML += `<div class="feedback feedback-general"><b>General Feedback:</b> ${sanitizedFeedback}</div>`;
        }
    }
    
    function updateScoreDisplay() {
        const perc = scorableQuestionsAttempted > 0 ? ((score / scorableQuestionsAttempted) * 100).toFixed(0) : 0;
        scoreDisplay.textContent = `Score: ${score} / ${scorableQuestionsAttempted} (${perc}%)`;
    }

    function updateProgressDisplay() {
        if (!quizData) return;
        const totalQuestions = quizData.length;
        const questionsToShow = Math.min(currentQuestionIndex + 1, totalQuestions);
        const progressPerc = totalQuestions > 0 ? ((questionsToShow / totalQuestions) * 100) : 0;

        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');

        if (progressBar && progressText) {
            progressBar.style.width = `${progressPerc}%`;
            progressText.textContent = `Question ${questionsToShow} of ${totalQuestions}`;
        }
    }

    function displayFinalScore() {
        questionArea.innerHTML = '<h2>Quiz Complete!</h2>';
        feedbackArea.innerHTML = `<p>You have finished the quiz. Your final score is shown above.</p>`;
        nextBtn.style.display = 'none'; categoryDisplay.innerHTML = '';

        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        if (progressBar && progressText) {
            progressBar.style.width = '100%';
            progressText.textContent = `Quiz Complete! ${quizData.length} of ${quizData.length}`;
        }
    }

    function escapeHTML(str) {
        const p = document.createElement("p"); p.textContent = str; return p.innerHTML;
    }
</script>
</body>
</html>
