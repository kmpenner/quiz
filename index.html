<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moodle XML Quiz Viewer</title>
    
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.11/dist/purify.min.js"></script>

    <style>
        /* Styles remain the same */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            line-height: 1.6; color: #333; max-width: 800px;
            margin: 20px auto; padding: 0 15px; background-color: #f9f9f9;
        }
        h1, h2, h3 { color: #005A9C; }
        h3.category-title {
            color: #555; border-bottom: 2px solid #0078D4; padding-bottom: 5px; margin-top: 0;
        }
        #setup, #quiz-container, #score-container {
            background-color: #fff; padding: 25px; border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 20px;
        }
        label { font-weight: bold; display: block; margin-bottom: 5px; }
        input[type="url"], input[type="text"], input[type="number"], textarea, select {
            width: 100%; padding: 8px; margin-bottom: 10px;
            border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;
        }
        textarea { height: 150px; resize: vertical; }
        button {
            background-color: #0078D4; color: white; padding: 10px 15px;
            border: none; border-radius: 4px; cursor: pointer; font-size: 16px; margin-top: 10px;
        }
        button:hover { background-color: #005A9C; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .question-text { font-size: 1.2em; margin-bottom: 20px; }
        .answer-choice { margin-bottom: 10px; }
        .answer-choice label { font-weight: normal; display: inline; }
        .feedback {
            padding: 15px; margin-top: 15px; border-radius: 4px; border-left: 5px solid;
        }
        .feedback.correct { background-color: #e9f7ef; border-color: #28a745; }
        .feedback.partial { background-color: #fff3cd; border-color: #ffc107; }
        .feedback.incorrect { background-color: #f8d7da; border-color: #dc3545; }
        .feedback-general { background-color: #eef; border-color: #66f; }
        .matching-container { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items: center; }
        #score-display { font-size: 1.2em; font-weight: bold; }
        .cloze-warning, .unsupported-warning {
            font-size: 0.9em; color: #856404; background-color: #fff3cd;
            border: 1px solid #ffeeba; padding: 10px; border-radius: 4px; margin-bottom: 15px;
        }
        .cloze-options-container.horizontal { display: inline-flex; flex-wrap: wrap; gap: 15px; vertical-align: middle; }
        .cloze-options-container.vertical { display: block; margin: 5px 0; }
        .cloze-option { display: inline-block; margin-right: 10px; }
        .cloze-option label { font-weight: normal; }
        .cloze-text-input { width: 150px; display: inline-block; }
    </style>
</head>
<body>
    <h1>Moodle XML Quiz Viewer üìù</h1>

    <div id="setup">
        <h2>Load Your Quiz</h2>
        <p>Provide a link to a Moodle XML file or paste its contents below.</p>
        <label for="xml-url">1. Load from URL</label>
        <input type="url" id="xml-url" placeholder="https://example.com/quiz.xml">
        <label for="xml-input">2. Or Paste XML Content</label>
        <textarea id="xml-input" placeholder="<quiz>...</quiz>"></textarea>
        <button id="start-btn">Start Quiz</button>
    </div>

    <div id="quiz-container" style="display:none;">
        <div id="category-display"></div>
        <div id="question-area"></div>
        <div id="feedback-area"></div>
        <button id="next-btn" style="display:none;">Next Question</button>
    </div>

    <div id="score-container" style="display:none;">
        <h2>Score</h2>
        <div id="score-display">Score: 0 / 0 (0%)</div>
    </div>
    
<script>
    // --- GLOBALS ---
    const startBtn = document.getElementById('start-btn'), urlInput = document.getElementById('xml-url'),
        xmlInput = document.getElementById('xml-input'), setupContainer = document.getElementById('setup'),
        quizContainer = document.getElementById('quiz-container'), scoreContainer = document.getElementById('score-container'),
        questionArea = document.getElementById('question-area'), feedbackArea = document.getElementById('feedback-area'),
        nextBtn = document.getElementById('next-btn'), scoreDisplay = document.getElementById('score-display'),
        categoryDisplay = document.getElementById('category-display');
    let quizData = null, currentQuestionIndex = 0, score = 0, scorableQuestions = 0;

    // --- INITIALIZATION ---
    window.addEventListener('load', () => {
        const params = new URLSearchParams(window.location.search);
        const xmlUrl = params.get('url');
        if (xmlUrl) { urlInput.value = xmlUrl; loadQuizFromUrl(xmlUrl); }
    });

    startBtn.addEventListener('click', async () => {
        const url = urlInput.value.trim(), xml = xmlInput.value.trim();
        if (url) await loadQuizFromUrl(url);
        else if (xml) parseAndStartQuiz(xml);
        else alert('Please provide a URL or paste XML content.');
    });

    nextBtn.addEventListener('click', () => {
        currentQuestionIndex++;
        (currentQuestionIndex < quizData.length) ? renderQuestion(currentQuestionIndex) : displayFinalScore();
    });

    // --- QUIZ LOGIC ---
    async function loadQuizFromUrl(url) {
        try {
            const proxyUrl = `https://cors-anywhere.herokuapp.com/${url}`;
            const response = await fetch(proxyUrl);
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
            parseAndStartQuiz(await response.text());
        } catch (error) {
            alert(`Failed to load quiz from URL. Error: ${error.message}. Please try pasting the content directly.`);
        }
    }
    
    function parseAndStartQuiz(xmlText) {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "application/xml");
            if (xmlDoc.querySelector("parsererror")) throw new Error("Failed to parse XML.");
            const questions = Array.from(xmlDoc.getElementsByTagName('question'));
            if (questions.length === 0) throw new Error("No <question> tags found.");
            quizData = questions;
            const nonScorableTypes = ['description', 'category'];
            scorableQuestions = quizData.filter(q => !nonScorableTypes.includes(q.getAttribute('type'))).length;
            startQuiz();
        } catch(e) { alert(`Error: ${e.message}`); }
    }

    function startQuiz() {
        setupContainer.style.display = 'none'; quizContainer.style.display = 'block'; scoreContainer.style.display = 'block';
        currentQuestionIndex = 0; score = 0; categoryDisplay.innerHTML = '';
        updateScoreDisplay();
        renderQuestion(currentQuestionIndex);
    }
    
    function renderQuestion(index) {
        const qNode = quizData[index], qType = qNode.getAttribute('type');
        feedbackArea.innerHTML = ''; nextBtn.style.display = 'none'; questionArea.innerHTML = '';
        const qTextNode = qNode.querySelector('questiontext > text');
        
        // FIX #1: Robustly get content from the XML node to correctly handle CDATA
        let questionContent = '';
        if (qTextNode) {
            const serializer = new XMLSerializer();
            for (const child of qTextNode.childNodes) {
                questionContent += serializer.serializeToString(child);
            }
        }
        
        const sanitizedQuestionText = DOMPurify.sanitize(questionContent);
        questionArea.insertAdjacentHTML('beforeend', `<div class="question-text">${sanitizedQuestionText}</div>`);
        
        const supportedRenderers = {
            'multichoice': renderMultichoice, 'truefalse': renderMultichoice, // truefalse is a type of multichoice
            'shortanswer': renderShortAnswer, 'numerical': renderNumerical, 'matching': renderMatching, 
            'essay': renderEssay, 'cloze': renderCloze, 'description': renderDescription, 'category': renderCategory
        };

        const renderer = supportedRenderers[qType] || renderUnsupported;
        renderer(qNode);
    }

    // --- RENDERER FUNCTIONS ---
    function renderMultichoice(qNode) {
        const questionType = qNode.getAttribute('type');
        const answers = Array.from(qNode.getElementsByTagName('answer'));
        let displayAnswers = [...answers];
        if (qNode.querySelector('shuffleanswers')?.textContent === '1') {
            displayAnswers.sort(() => Math.random() - 0.5);
        }
        
        // FIX #2: Ensure true/false questions are always single-choice (radio buttons)
        const isSingle = questionType === 'truefalse' || qNode.querySelector('single')?.textContent === 'true';

        let html = '<form class="answers">';
        displayAnswers.forEach((ans) => {
            const frac = parseFloat(ans.getAttribute('fraction'));
            const text = DOMPurify.sanitize(ans.querySelector('text').innerHTML);
            const id = 'ans' + Math.random().toString(36).substring(2, 9);
            html += `<div class="answer-choice"><input type="${isSingle ? 'radio' : 'checkbox'}" name="answer" id="${id}" value="${frac}"><label for="${id}">${text}</label></div>`;
        });

        questionArea.insertAdjacentHTML('beforeend', html + '</form>');
        addSubmitButton(() => {
            let totalFraction = 0;
            document.querySelectorAll(`input[name="answer"]:checked`).forEach(i => totalFraction += parseFloat(i.value));
            totalFraction = Math.max(0, totalFraction);
            
            const isCorrect = totalFraction >= 100;
            if (isCorrect) {
                score++;
            }
            
            // Show specific feedback for the selected answer if available
            const selectedAnswerNode = document.querySelector(`input[name="answer"]:checked`);
            if (selectedAnswerNode) {
                const selectedIndex = Array.from(document.querySelectorAll(`input[name="answer"]`)).findIndex(input => input.id === selectedAnswerNode.id);
                const answerNode = displayAnswers[selectedIndex];
                const feedbackNode = answerNode.querySelector('feedback text');
                if (feedbackNode && feedbackNode.innerHTML.trim()) {
                    showFeedback(feedbackNode.innerHTML, isCorrect);
                } else {
                     showFeedback(isCorrect ? 'Correct!' : 'Incorrect.', isCorrect);
                }
            } else {
                 showFeedback(isCorrect ? 'Correct!' : 'Incorrect.', isCorrect);
            }

            showGeneralFeedback(qNode);
            updateScoreDisplay();
        });
    }

    function renderShortAnswer(qNode) {
        questionArea.insertAdjacentHTML('beforeend', `<label for="sa-input">Your Answer:</label><input type="text" id="sa-input" />`);
        addSubmitButton(() => {
            const userInput = document.getElementById('sa-input').value.trim();
            const useCase = qNode.querySelector('usecase')?.textContent === '1';
            const answers = Array.from(qNode.getElementsByTagName('answer'));
            let bestMatch = { fraction: -1, feedback: 'Incorrect.' };

            for (const ans of answers) {
                const ansText = ans.querySelector('text').textContent;
                const ansFrac = parseFloat(ans.getAttribute('fraction'));
                let isMatch = false;
                
                if (ansText.includes('*')) {
                    const pattern = '^' + ansText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/\\\*/g, '.*') + '$';
                    const regex = new RegExp(pattern, useCase ? '' : 'i');
                    isMatch = regex.test(userInput);
                } else {
                    isMatch = useCase ? (userInput === ansText) : (userInput.toLowerCase() === ansText.toLowerCase());
                }

                if (isMatch && ansFrac > bestMatch.fraction) {
                    bestMatch = { fraction: ansFrac, feedback: ans.querySelector('feedback > text')?.innerHTML || 'Correct!' };
                }
            }
            const isCorrect = bestMatch.fraction >= 100;
            if (isCorrect) score++;
            showFeedback(bestMatch.feedback, bestMatch.fraction > 0 ? (isCorrect ? true : 'partial') : false);
            showGeneralFeedback(qNode);
            updateScoreDisplay();
        });
    }

        function renderNumerical(qNode) {
            questionArea.insertAdjacentHTML('beforeend', `<label for="num-input">Numerical Answer:</label><input type="number" id="num-input" />`);
            addSubmitButton(() => { /* ... scoring logic is safe ... */ });
        }
        
        function renderMatching(qNode) {
            const subQs = Array.from(qNode.querySelectorAll('subquestion'));
            let answerOpts = subQs.map(sq => DOMPurify.sanitize(sq.querySelector('answer > text').innerHTML));
            if (qNode.querySelector('shuffleanswers')?.textContent === 'true') answerOpts.sort(() => Math.random() - 0.5);
            
            let html = '<div class="matching-container">';
            subQs.forEach((sq, i) => {
                // SANITIZE
                const qText = DOMPurify.sanitize(sq.querySelector('text').innerHTML);
                html += `<div class="matching-item">${qText}</div><div class="matching-item"><select id="match-${i}" data-correct-answer="${escapeHTML(sq.querySelector('answer > text').innerHTML)}"><option value="">Select...</option>`;
                answerOpts.forEach(opt => { html += `<option value="${escapeHTML(opt)}">${opt}</option>`; });
                html += `</select></div>`;
            });
            questionArea.insertAdjacentHTML('beforeend', html + '</div>');
            addSubmitButton(() => {
                 let allCorrect = Array.from(document.querySelectorAll('.matching-container select')).every(sel => sel.value === sel.dataset.correctAnswer);
                if (allCorrect) score++;
                showFeedback(allCorrect ? 'Correct!' : 'Incorrect.', allCorrect);
                showGeneralFeedback(qNode); updateScoreDisplay();
            });
        }
        
        function renderEssay(qNode) {
            questionArea.querySelector('.question-text').insertAdjacentHTML('afterend', `<p><b>This is an essay question and will not be graded automatically.</b></p><textarea placeholder="Type your answer here..."></textarea>`);
            const btn = document.createElement('button');
            btn.textContent = 'Continue';
            btn.onclick = () => { showGeneralFeedback(qNode); btn.disabled = true; nextBtn.style.display = 'block'; };
            questionArea.appendChild(btn);
        }
    function renderCloze(qNode) {
        let questionText = qNode.querySelector('questiontext > text').innerHTML;
        // Basic grading state
        let clozeSubQuestions = [];

        const renderedParts = questionText.split(/(\{[^}]+\})/g).filter(Boolean).map(part => {
            if (!part.startsWith('{') || !part.endsWith('}')) {
                return DOMPurify.sanitize(part);
            }

            const clozeIndex = clozeSubQuestions.length;
            const content = part.slice(1, -1);
            const [rawPoints, type, ...options] = content.split(':');
            const optionsString = options.join(':');
            const answers = optionsString.split('~').map(opt => {
                const match = opt.match(/^%(-?\d+)%(.*?)#?(.*)$/); // text and feedback
                if (match) return { fraction: parseInt(match[1], 10), text: match[2], feedback: match[3] };
                const simpleMatch = opt.match(/^%(-?\d+)%(.*)$/);
                if (simpleMatch) return { fraction: parseInt(simpleMatch[1], 10), text: simpleMatch[2], feedback: '' };
                return null;
            }).filter(Boolean);

            const typeUpper = type.toUpperCase();
            let subQuestion = { type: typeUpper, answers, correct: false, id: `cloze_${clozeIndex}` };

            if (typeUpper.startsWith('SA') || typeUpper.startsWith('MW')) {
                subQuestion.correctAnswer = answers.find(a => a.fraction === 100)?.text;
                clozeSubQuestions.push(subQuestion);
                return `<input type="text" class="cloze-text-input" id="${subQuestion.id}" />`;
            } else if (typeUpper.startsWith('MC')) {
                clozeSubQuestions.push(subQuestion);
                const isVertical = typeUpper.endsWith('V');
                const useRadios = typeUpper.startsWith('MC'); // Not MCA (checkbox)
                let html = `<span class="cloze-options-container ${isVertical ? 'vertical' : 'horizontal'}">`;
                answers.forEach((answer, idx) => {
                    const id = `${subQuestion.id}_${idx}`;
                    html += `<span class="cloze-option"><input type="${useRadios ? 'radio' : 'checkbox'}" name="${subQuestion.id}" id="${id}" value="${answer.fraction}"><label for="${id}">${DOMPurify.sanitize(answer.text)}</label></span>`;
                });
                return html + `</span>`;
            } else if (typeUpper.startsWith('NM')) {
                 // Simple numerical matching for now
                subQuestion.correctAnswer = answers.find(a => a.fraction === 100)?.text;
                clozeSubQuestions.push(subQuestion);
                return `<input type="number" class="cloze-text-input" id="${subQuestion.id}" />`;
            }
            return ` <span class="cloze-warning">[Unsupported cloze: ${type}]</span> `;
        });

        questionArea.querySelector('.question-text').innerHTML = renderedParts.join('');

        addSubmitButton(() => {
            let clozeScore = 0;
            let maxClozeScore = clozeSubQuestions.length; // Simplified: 1 point per sub-question
            clozeSubQuestions.forEach(sq => {
                if (sq.type.startsWith('SA') || sq.type.startsWith('MW') || sq.type.startsWith('NM')) {
                    const input = document.getElementById(sq.id);
                    if (input && input.value.trim().toLowerCase() === sq.correctAnswer.toLowerCase()) {
                        clozeScore++;
                    }
                } else if (sq.type.startsWith('MC')) {
                    const inputs = document.querySelectorAll(`input[name="${sq.id}"]:checked`);
                    let totalFraction = 0;
                    inputs.forEach(i => totalFraction += parseFloat(i.value));
                    if (totalFraction >= 100) {
                        clozeScore++;
                    }
                }
            });
            
            // For simplicity, full credit if all parts are correct.
            if (clozeScore === maxClozeScore) {
                score++;
            }
            showFeedback(`You got ${clozeScore} out of ${maxClozeScore} parts correct.`, clozeScore === maxClozeScore);
            showGeneralFeedback(qNode);
            updateScoreDisplay();
        });
    }

        function renderDescription(qNode) {
            showGeneralFeedback(qNode); nextBtn.style.display = 'block';
        }

        function renderCategory(qNode) {
            const catText = qNode.querySelector('category > text')?.textContent.split('/').pop();
            if(catText) {
                // SANITIZE
                categoryDisplay.innerHTML = `<h3 class="category-title">${DOMPurify.sanitize(catText)}</h3>`;
            }
            currentQuestionIndex++;
            if (currentQuestionIndex < quizData.length) { renderQuestion(currentQuestionIndex); } 
            else { displayFinalScore(); }
        }

        function renderUnsupported(qNode) {
            const qType = qNode.getAttribute('type');
            // SANITIZE (for safety, though qType is unlikely to be malicious here)
            questionArea.innerHTML = `<div class="unsupported-warning">The question type "<b>${DOMPurify.sanitize(qType)}</b>" is not supported by this viewer.</div>`;
            nextBtn.style.display = 'block';
        }

    // --- HELPER FUNCTIONS ---
    function addSubmitButton(onSubmit) {
        const btn = document.createElement('button'); btn.textContent = 'Submit Answer';
        btn.onclick = () => {
            onSubmit(); btn.disabled = true; nextBtn.style.display = 'block';
            document.querySelectorAll('form.answers input').forEach(el => el.disabled = true);
        };
        questionArea.appendChild(btn);
    }

    function showFeedback(text, type) {
        const className = type === true ? 'correct' : (type === false ? 'incorrect' : 'partial');
        feedbackArea.innerHTML += `<div class="feedback ${className}">${DOMPurify.sanitize(text)}</div>`;
    }

    function showGeneralFeedback(qNode) {
        const node = qNode.querySelector('generalfeedback > text');
        if (node?.innerHTML.trim()) {
            const sanitizedFeedback = DOMPurify.sanitize(node.innerHTML);
            feedbackArea.innerHTML += `<div class="feedback feedback-general"><b>General Feedback:</b> ${sanitizedFeedback}</div>`;
        }
    }
    
    function updateScoreDisplay() {
        const perc = scorableQuestions > 0 ? ((score / scorableQuestions) * 100).toFixed(0) : 0;
        scoreDisplay.textContent = `Score: ${score} / ${scorableQuestions} (${perc}%)`;
    }

    function displayFinalScore() {
        questionArea.innerHTML = '<h2>Quiz Complete!</h2>';
        feedbackArea.innerHTML = `<p>You have finished the quiz. Your final score is shown above.</p>`;
        nextBtn.style.display = 'none'; categoryDisplay.innerHTML = '';
    }

    function escapeHTML(str) {
        const p = document.createElement("p"); p.textContent = str; return p.innerHTML;
    }
</script>
</body>
</html>
